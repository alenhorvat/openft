// SPDX-License-Identifier: MIT
// OpeNFT smart contract v0.2.0
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";

/**
 * @dev Implementation of OpeNFT smart contract based on the ERC-721 token standard
 * @custom:security-contact security@openft.world
 * TODO: check what to do with the URI
 * TODO: add events
 * TODO: document the methods
 */
contract OpeNFT is ERC721, ERC721URIStorage {

    /**
     * @notice _timestampsRegistry is a registry of all NFT ID timestamps. You cannot mint a token without timestamping the NFT ID first.
     * type: map: nft id -> block number
     *
     * Timestamps are immutable.
     */
    mapping(bytes32 => uint256) private _timestampsRegistry;

    /**
     * @notice timestamp timestamps an NFT ID by storing it in the Timestamps Registry. Anyone can timestamp an NFT ID, but only the author can mint it
     * @dev The method stores the nftId. Anyone can register the nftId since the ownership is set in the minting step.
     * @param nftId is the unique NFT identifier we are timestamping
     * 
     * NFT ID without authorship statement
     *   - eth_addr is the author's ethereum address
     *   - digital asset identifier is hash of the digital asset `asset_id = sha256(digital asset id)`
     *   - NFT id is `nft_id = sha256(eth_addr || asset_id)`
     * 
     * NFT ID with authorship statement
     *   - eth_addr is the author's ethereum address
     *   - digital asset identifier is hash of the digital asset `asset_id = sha256(digital asset id)`
     *   - authorship statement id is hash of the authorship statement `as_id = sha256(authorsip statement)`
     *   - NFT ID is `nft_id = sha256(eth_addr || asset_id || as_id)`
     * 
     * @param nftId is the NFT id
     */
    function timestamp(bytes32 nftId) public virtual {
        // Check whether the NFT ID is already registered
        require(!_isTimestamped(nftId), "Notice: NFT id is already timestamped");
        // Register the NFT ID
        _timestampsRegistry[nftId] = block.number;
        // TODO: add event
    }

    /**
     * @notice _isTimestamped checks whether the NFT ID has already been timestamped
     * @param nftId is the NFT ID
     */
    function _isTimestamped(bytes32 nftId) internal view virtual returns (bool) {
        return _timestampsRegistry[nftId] != 0;
    }

    /**
     * @notice getTimestamp is a public method that returns the NFT ID timestamp
     * @param nftId is the NFT id
     */
    function getTimestamp(bytes32 nftId) public view returns (uint256) {
        return _timestampsRegistry[nftId];
    }

    /**
     * @notice mint is a public method that allows authors to mint their NFTs after they timestamped the NFT ID
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *  - NFT ID must be registered
     * @param to is address of the NFT owner
     * @param assetId is a hash of a unique digital or physical asset id
     * // TODO: remove 1 for "production": See: https://github.com/NomicFoundation/hardhat/issues/1869
     */
    function safeMint1(address to, bytes32 assetId, string memory uri) public {
        bytes32 nftIdComputed = computeNftId(_msgSender(), assetId);
        // Verifyt he proof
        require(_beforeMint(nftIdComputed, assetId), "Error: Unauthorised to mint.");

        _safeMint(to, uint256(nftIdComputed));
        _setTokenURI(uint256(nftIdComputed), uri);
    }
    /**
     * @notice mint is a public method that allows authors to mint their NFTs after they timestamped the NFT ID
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *  - NFT ID must be registered
     * @param to is address of the NFT owner
     * @param assetId is a hash of a unique digital or physical asset id
     * @param authorshipStatementId is a hash of the authorship statement
     */
    function safeMint(address to, bytes32 assetId, bytes32 authorshipStatementId, string memory uri) public {
        bytes32 nftIdComputed = computeVerifiableNftId(_msgSender(), assetId, authorshipStatementId);
        // Verifyt he proof
        require(_beforeMint(nftIdComputed, assetId), "Error: Unauthorised to mint.");

        _safeMint(to, uint256(nftIdComputed));
        _setTokenURI(uint256(nftIdComputed), uri);
    }

    /**
    * @notice _idRegistry is a registry of all minted asset ids
    * type: map: asset id to nft id
    * To prevent front-running, we always check whether NFT ID linked to the id is the oldest
    */
    mapping(bytes32 => bytes32) private _idRegistry;

    /**
    * @notice getAssetNftId returns NFT ID bound to the asset id
    */
    function getNftId(bytes32 assetId) public view returns (bytes32) {
        return _idRegistry[assetId];
    }

    /**
     * @notice computeNftId is an internal function that computes the NFT id from sender's address and the assetId
     */
    function computeNftId(address sender, bytes32 assetId) public pure returns (bytes32) {
        // Concatenate sender's address and the asset id
        bytes memory _nid = bytes.concat(bytes20(sender), assetId);
        return sha256(_nid);
    }

    /**
     * @notice _computeVerifiableNftId is an internal function that computes the NFT id from sender's address, the assetId, and authorshipStatementId
     */
    function computeVerifiableNftId(address sender, bytes32 assetId, bytes32 authorshipStatementId) public pure returns (bytes32) {

        // Compute verifiable asset ID: sha256(assetId, authorshipStatementId)
        bytes memory _verifiableAssetId = bytes.concat(assetId, authorshipStatementId);
        bytes32 verifiableAssetId = sha256(_verifiableAssetId);

        // Compute NFT ID as: sha256(msg.sender, verifiableAssetId)
        bytes memory _nid = bytes.concat(bytes20(sender), verifiableAssetId);
        return sha256(_nid);
    }

    /**
     * @dev _beforeMint performs all the checks and updates all the entries
     */
    function _beforeMint(bytes32 nftIdComputed, bytes32 assetId) internal virtual returns (bool) {

        // Check that the nft id is already timestamped
        // require(_isTimestamped(nftIdComputed), string.concat("Error. NFT ID is not timestamped.\n", iToHex(bytes.concat(nftIdComputed))));
        require(_isTimestamped(nftIdComputed), string.concat("Error. NFT ID is not timestamped."));

        // Register the asset id or update the link to the NFT ID if someone front-run us
        if(_idRegistry[assetId] == 0) {
            // ID is not registered, register it
            _idRegistry[assetId] = nftIdComputed;
        } else {
            // ID is registered, check if someone performed a front-run
            bytes32 _linkedNftId = _idRegistry[assetId];
            if(_timestampsRegistry[nftIdComputed] < _timestampsRegistry[_linkedNftId]) {
                // Someone front-run us, we are re-claiming the ownership
              _idRegistry[assetId] = nftIdComputed;
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * Initialises the standard NFT smart contract
     */
    constructor() ERC721("OpeNFT", "ONFT") {}

    function _baseURI() internal pure override returns (string memory) {
        return "";
    }

    // The following functions are overrides required by Solidity.

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }
}